<!doctype html>
<script>
  function canvasStream() {
    const cvs = document.createElement("canvas");
    ([cvs.width, cvs.height] = [512, 512]);
    const ctx = cvs.getContext('2d');
    return new ReadableStream({
      start(controller) {
        for (let i = 0; i < 60; i++) {
          ctx.fillStyle = 'red';
          ctx.fillRect(0, 0, 512, 512);
          ctx.fillStyle = 'blue';
          ctx.fillRect(i, i, 10, 10);
          const { data } = ctx.getImageData(0, 0, 512, 512);
          controller.enqueue(data.buffer);
        }
        controller.close();
      }
    });
  }

  function cameraStream() {
    return new ReadableStream({
      async start(controller) {
        const cvs = document.createElement("canvas");
        const video = document.createElement("video");
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: {ideal: 640},
            height: {ideal: 360},
          },
          audio: false
        });
        video.srcObject = stream;
        video.play();
        await new Promise(resolve => video.onplaying = resolve);
        ([cvs.width, cvs.height] = [video.videoWidth, video.videoHeight]);
        console.log(cvs.width, cvs.height);
        const ctx = cvs.getContext("2d");
        requestAnimationFrame(function f() {
          ctx.drawImage(video, 0, 0);
          controller.enqueue(ctx.getImageData(0, 0, cvs.width, cvs.height).data.buffer);
          requestAnimationFrame(f);
        });
      }
    });
  }

  async function init(realtime) {
    const worker = new Worker("worker.js");
    // Wait for worker + wasm to be ready
    await new Promise(resolve => worker.addEventListener("message", resolve, {once: true}));
    // Initialize encoder
    worker.postMessage([1, 60, 640, 360, 200 /*bitrate*/, realtime]);

    let stream;
    if(realtime) {
      stream = cameraStream();
    } else {
      stream = canvasStream();
    }
    stream.pipeTo(new WritableStream({
      write(buffer) {
        worker.postMessage(buffer, [buffer]);
      },
      close() {
        // Signal end-of-stream
        worker.postMessage(null);
      }
    }));

    if(realtime) {
      await streamResult(worker);
    } else {
      await showResultFile(worker);
    }
  }

  async function streamResult(worker) {
    const stream = new ReadableStream({
      start(controller) {
        worker.addEventListener("message", ev => {
          if(!ev.data) {
            return controller.close();
          }
          controller.enqueue(ev.data);
        });
      }
    })
    const video = document.createElement("video");
    video.muted = true;
    video.autoplay = true;
    video.loop = true;
    video.controls = true;
    video.src = mediaSourceStream(stream, {mimeType: `video/webm; codecs="vp8"`});
    document.body.append(video);
    video.play();
  }

  function mediaSourceStream(stream, {mimeType}) {
    const mediaSource = new MediaSource();
    mediaSource.onsourceopen = () => {
      const sourceBuffer = mediaSource.addSourceBuffer(mimeType);
      stream.pipeTo(new WritableStream({
        async write(chunk) {
          sourceBuffer.appendBuffer(chunk);
          // This handles backpressure
          await new Promise(resolve => {
            sourceBuffer.addEventListener("updateend", resolve, {once: true});
          });
        },
        close() {
          mediaSource.endOfStream();
        }
      }));
    };
    return URL.createObjectURL(mediaSource);
  }

  async function showResultFile(worker) {
    // Wait for webm file
    const result = await new Promise(resolve => {
      worker.addEventListener("message", ev => resolve(ev.data), {once: true});
    });
    const blobUrl = URL.createObjectURL(new Blob([result], {type: "video/webm"}));
    console.log('Done');
    console.log(`Total file size: ${result.byteLength}`);
    worker.terminate();
    const video = document.createElement("video");
    video.muted = true;
    video.autoplay = true;
    video.loop = true;
    video.controls = true;
    video.src = blobUrl;
    document.body.append(video);
    video.play();
  }
  init(true);
</script>
