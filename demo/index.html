<!doctype html>
<h1>wasm webm encoder</h1>
<div>
Options (as query parameters):
<dl>
  <dt><code>realtime</code></dt>
  <dd>Put encoder into realtime mode and encode a <code>getUserMedia()</code> camera stream in real time</dd>
  <dt><code>framerate</code></dt>
  <dd>Set the target framerate (default 30)</dd>
  <dt><code>bitrate</code></dt>
  <dd>Set the target bitrate in kbps (default 200)</dd>
</dl>
Example: <a href="?realtime&framerate=60"><code>?realtime&framerate=60</code></a>
</div>
<script>
  const params = new URLSearchParams(location.search);
  const realtime = params.has("realtime");
  const framerate = Number(params.get("framerate")) || 30;
  const bitrate = Number(params.get("bitrate")) || 200;

  function canvasStream() {
    const cvs = document.createElement("canvas");
    ([cvs.width, cvs.height] = [512, 512]);
    const ctx = cvs.getContext('2d');
    return new ReadableStream({
      async start(controller) {
        for (let i = 0; i < 60; i++) {
          ctx.fillStyle = 'red';
          ctx.fillRect(0, 0, 512, 512);
          ctx.fillStyle = 'blue';
          ctx.fillRect(i, i, 10, 10);
          await controller.enqueue(ctx.getImageData(0, 0, 512, 512));
        }
        controller.close();
      }
    });
  }

  function cameraStream() {
    return new ReadableStream({
      async start(controller) {
        const cvs = document.createElement("canvas");
        const video = document.createElement("video");
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: {ideal: 400},
            height: {ideal: 300},
          },
          audio: false
        });
        video.srcObject = stream;
        video.play();
        await new Promise(resolve => video.onplaying = resolve);
        ([cvs.width, cvs.height] = [video.videoWidth, video.videoHeight]);
        const ctx = cvs.getContext("2d");
        const frameTimeout = 1000/framerate;
        setTimeout(async function f() {
          ctx.drawImage(video, 0, 0);
          await controller.enqueue(ctx.getImageData(0, 0, cvs.width, cvs.height));
          setTimeout(f, frameTimeout);
        }, frameTimeout);
      }
    });
  }

  async function getFirstItem(stream_) {
    const [rs1, stream] = stream_.tee();
    const reader = rs1.getReader();
    const {value, done} = await reader.read();
    if(done) {
      throw Error("There was no first item");
    }
    reader.releaseLock();
    rs1.cancel();
    return {value, stream};
  }

  function nextEvent(target, name) {
    return new Promise(resolve => {
      target.addEventListener(name, resolve, {once: true});
    });
  }

  function getBuffer() {
    return new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(chunk.data.buffer);
      }
    });
  }

  async function init() {
    const worker = new Worker("worker.js");
    if((await nextEvent(worker, "message")).data !== "READY") {
      throw Error("Unexpected initialization response");
    }

    // Get the first item from the stream to know the dimensions
    const {stream, value} = await getFirstItem(realtime ? cameraStream() : canvasStream());
    worker.postMessage([1, framerate, value.width, value.height, bitrate, realtime]);
    const webmTransform = (await nextEvent(worker, "message")).data;

    const webmStream = stream
      .pipeThrough(getBuffer())
      .pipeThrough(webmTransform);
    const webmMediaStream = mediaSourceStream(webmStream, {mimeType: `video/webm; codecs="vp8"`});

    const video = document.createElement("video");
    video.muted = true;
    video.autoplay = true;
    video.loop = true;
    video.controls = true;
    video.src = webmMediaStream;
    document.body.append(video);
    video.play();
  }

  function mediaSourceStream(stream, {mimeType}) {
    const mediaSource = new MediaSource();
    mediaSource.onsourceopen = () => {
      const sourceBuffer = mediaSource.addSourceBuffer(mimeType);
      stream.pipeTo(new WritableStream({
        async write(chunk) {
          sourceBuffer.appendBuffer(chunk); // This handles backpressure
          await new Promise(resolve => {
            sourceBuffer.addEventListener("updateend", resolve, {once: true});
          });
        },
        close() {
          mediaSource.endOfStream();
        }
      }));
    };
    return URL.createObjectURL(mediaSource);
  }
  init();
</script>
