<!doctype html>
<script>
  function canvasStream() {
    const cvs = document.createElement("canvas");
    ([cvs.width, cvs.height] = [512, 512]);
    const ctx = cvs.getContext('2d');
    return new ReadableStream({
      start(controller) {
        for (let i = 0; i < 60; i++) {
          ctx.fillStyle = 'red';
          ctx.fillRect(0, 0, 512, 512);
          ctx.fillStyle = 'blue';
          ctx.fillRect(i, i, 10, 10);
          const { data } = ctx.getImageData(0, 0, 512, 512);
          controller.enqueue(data.buffer);
        }
        controller.close();
      }
    });
  }

  async function init(realtime) {
    const worker = new Worker("worker.js");
    // Wait for worker + wasm to be ready
    await new Promise(resolve => worker.addEventListener("message", resolve, {once: true}));
    // Initialize encoder
    worker.postMessage([1, 30, 512, 512, 200 /*bitrate*/, realtime]);

    canvasStream().pipeTo(new WritableStream({
      write(buffer) {
        worker.postMessage(buffer, [buffer]);
      },
      close() {
        // Signal end-of-stream
        worker.postMessage(null);
      }
    }));

    if(realtime) {
      await streamResult(worker);
    } else {
      await showResultFile(worker);
    }
  }

  async function streamResult(worker) {
    const stream = new ReadableStream({
      start(controller) {
        worker.addEventListener("message", ev => {
          if(!ev.data) {
            return controller.close();
          }
          controller.enqueue(ev.data);
        });
      }
    })
    // const resp = new Response(stream, {headers: {"Content-Type": "video/webm"}});
    const video = document.createElement("video");
    video.muted = true;
    video.autoplay = true;
    video.loop = true;
    video.controls = true;
    video.src = mediaSourceStream(stream, {mimeType: `video/webm; codecs="vp8"`});
    document.body.append(video);
    video.play();
  }

  function mediaSourceStream(stream, {mimeType}) {
    const mediaSource = new MediaSource();
    mediaSource.onsourceopen = () => {
      const sourceBuffer = mediaSource.addSourceBuffer(mimeType);
      stream.pipeTo(new WritableStream({
        async write(chunk) {
          sourceBuffer.appendBuffer(chunk);
          // This handles backpressure
          await new Promise(resolve => {
            sourceBuffer.addEventListener("updateend", resolve, {once: true});
          });
        },
        close() {
          mediaSource.endOfStream();
        }
      }));
    };
    return URL.createObjectURL(mediaSource);
  }

  async function showResultFile(worker) {
    // Wait for webm file
    const result = await new Promise(resolve => {
      worker.addEventListener("message", ev => resolve(ev.data), {once: true});
    });
    const blobUrl = URL.createObjectURL(new Blob([result], {type: "video/webm"}));
    console.log('Done');
    console.log(`Total file size: ${result.byteLength}`);
    worker.terminate();
    const video = document.createElement("video");
    video.muted = true;
    video.autoplay = true;
    video.loop = true;
    video.controls = true;
    video.src = blobUrl;
    document.body.append(video);
    video.play();
  }
  init(true);
</script>
