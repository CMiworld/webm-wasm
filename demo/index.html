<!doctype html>
<script>
  function canvasStream() {
    const cvs = document.createElement("canvas");
    ([cvs.width, cvs.height] = [512, 512]);
    const ctx = cvs.getContext('2d');
    return new ReadableStream({
      start(controller) {
        for (let i = 0; i < 600; i++) {
          ctx.fillStyle = 'red';
          ctx.fillRect(0, 0, 512, 512);
          ctx.fillStyle = 'blue';
          ctx.fillRect(i, i, 10, 10);
          const { data } = ctx.getImageData(0, 0, 512, 512);
          controller.enqueue(data.buffer);
        }
        controller.close();
      }
    });
  }

  async function init(realtime) {
    const worker = new Worker("worker.js");
    // Wait for worker + wasm to be ready
    await new Promise(resolve => worker.addEventListener("message", resolve, {once: true}));
    // Initialize encoder
    worker.postMessage([1, 30, 512, 512, 200 /*bitrate*/, realtime]);

    canvasStream().pipeTo(new WritableStream({
      write(buffer) {
        worker.postMessage(buffer, [buffer]);
      },
      close() {
        // Signal end-of-stream
        worker.postMessage(null);
      }
    }));

    if(realtime) {
      await streamResult(worker);
    } else {
      await showResultFile(worker);
    }
  }

  async function showResultFile(worker) {
    // Wait for webm file
    const result = await new Promise(resolve => {
      worker.addEventListener("message", ev => resolve(ev.data), {once: true});
    });
    const blobUrl = URL.createObjectURL(new Blob([result], {type: "video/webm"}));
    console.log('Done');
    console.log(`Total file size: ${result.byteLength}`);
    worker.terminate();
    document.body.innerHTML = `<video src="${blobUrl}" autoplay loop muted controls></video>`;
  }
  init();
</script>
